name: X visibility monitor (GitHub Actions)

on:
  schedule:
    - cron: "0 * * * *"       # arranca de hora a hora (UTC)
  workflow_dispatch:

permissions:
  actions: read
  contents: read

concurrency:
  group: x-visibility-monitor
  cancel-in-progress: true

jobs:
  monitor-loop:
    runs-on: ubuntu-latest
    timeout-minutes: 59          # margem antes do limite de 60 min por job
    env:
      USERNAME: ${{ secrets.X_USERNAME }}
      UA: "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126 Safari/537.36"
      WINDOW_MINUTES: "55"       # ~55 min de checks (quase contínuo)
      SLEEP_SECONDS: "60"        # 1 pedido/min
    steps:
      - name: Echo start (hourly run)
        run: |
          echo "Start UTC: $(date -u '+%Y-%m-%d %H:%M:%S')"
          echo "Hourly run with ~${WINDOW_MINUTES} min loop."

      - name: Download last state/artifacts (if exist)
        id: prev
        uses: dawidd6/action-download-artifact@v6
        with:
          name: x-endpoint-${{ env.USERNAME }}
          path: prev
        continue-on-error: true

      - name: Monitor loop (minute checks; heartbeat=arranque; alerta só quando muda para PUBLIC)
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID:   ${{ secrets.TELEGRAM_CHAT_ID }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          # Estado base
          if [ -f prev/state.txt ]; then cp prev/state.txt out/state.txt; else echo "UNKNOWN" > out/state.txt; fi

          get_state() {
            local TS
            TS=$(date -u +%s)

            # 1) Widgets (única fonte que pode afirmar PUBLIC)
            for host in "https://cdn.syndication.twimg.com" "https://syndication.twitter.com"; do
              curl -sS --compressed --http1.1 \
                --connect-timeout 5 --max-time 10 \
                -H "User-Agent: ${UA}" \
                -H "Accept: application/json, text/javascript, */*; q=0.01" \
                -H "Referer: https://platform.twitter.com/" \
                "${host}/widgets/followbutton/info.json?screen_names=${USERNAME}&_=${TS}" \
                -o out/widgets.json || true
              if grep -qE '"protected"\s*:\s*true' out/widgets.json; then
                echo "PRIVATE"; echo "widgets:${host##https://}"; return
              elif grep -qE '"protected"\s*:\s*false' out/widgets.json; then
                echo "PUBLIC"; echo "widgets:${host##https://}"; return
              fi
            done

            # 2) Reader fallback — NUNCA diz PUBLIC
            local code size
            code=$(curl -sS --compressed -L --http1.1 \
                    --connect-timeout 5 --max-time 10 \
                    -H "User-Agent: ${UA}" \
                    -w "%{http_code}" \
                    -o out/profile.html \
                    "https://r.jina.ai/http://x.com/${USERNAME}" || true)
            size=$(wc -c < out/profile.html || echo 0)

            if [ "${code}" != "200" ] || [ "${size}" -lt 1500 ]; then
              echo "UNKNOWN"; echo "reader:jina"; return
            fi
            if grep -qiE "These posts are protected|This account is protected" out/profile.html; then
              echo "PRIVATE"; echo "reader:jina"; return
            elif grep -qiE "This account doesn’t exist|This account doesn't exist" out/profile.html; then
              echo "MISSING"; echo "reader:jina"; return
            else
              echo "UNKNOWN"; echo "reader:jina"; return
            fi
          }

          # Heartbeat no arranque (uma mensagem por hora a confirmar que corre)
          mapfile -t HB < <(get_state)
          HB_STATE="${HB[0]:-UNKNOWN}"
          HB_SRC="${HB[1]:-unknown}"
          if [ -n "${TELEGRAM_BOT_TOKEN:-}" ] && [ -n "${TELEGRAM_CHAT_ID:-}" ]; then
            NOW_UTC="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            NOW_PT="$(TZ=Europe/Lisbon date '+%Y-%m-%d %H:%M:%S %Z')"
            TEXT="$(printf '⚙️ *[GitHub Actions LOOP]*\nHeartbeat 1h: *%s* • Fonte: %s\nPerfil: [@%s](https://x.com/%s)\n🕒 Cadência ~1/min (loop interno)\n\nUTC: %s\nLisboa: %s' \
              "$HB_STATE" "$HB_SRC" "$USERNAME" "$USERNAME" "$NOW_UTC" "$NOW_PT")"
            curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d chat_id="${TELEGRAM_CHAT_ID}" -d parse_mode="Markdown" \
              --data-urlencode "text=${TEXT}" >/dev/null || true
          fi
          echo "${HB_STATE}" > out/state.txt

          # Loop com deadline (cobre ~55 min)
          START_EPOCH=$(date -u +%s)
          DEADLINE=$(( START_EPOCH + WINDOW_MINUTES*60 ))
          ITER=1
          while true; do
            NOW=$(date -u +%s)
            if [ "$NOW" -ge "$DEADLINE" ]; then
              echo "Reached ${WINDOW_MINUTES} min window. Exiting."
              break
            fi

            NOW_UTC_MIN="$(date -u '+%Y-%m-%d %H:%M:%S')"
            echo "::group::[${NOW_UTC_MIN}] Iteration ${ITER}"

            PREV_STATE="$(tr -d '\r\n' < out/state.txt || echo UNKNOWN)"
            mapfile -t RES < <(get_state)
            CUR_STATE="${RES[0]:-UNKNOWN}"
            SRC="${RES[1]:-unknown}"
            echo "Current: $CUR_STATE (via $SRC) | Previous: $PREV_STATE"

            # Alertar só se transita para PUBLIC, com dupla confirmação
            if [ "$CUR_STATE" = "PUBLIC" ] && [ "$PREV_STATE" != "PUBLIC" ]; then
              mapfile -t RES2 < <(get_state)
              if [ "${RES2[0]:-UNKNOWN}" = "PUBLIC" ]; then
                if [ -n "${TELEGRAM_BOT_TOKEN:-}" ] && [ -n "${TELEGRAM_CHAT_ID:-}" ]; then
                  NOW_UTC_TS="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
                  NOW_PT_TS="$(TZ=Europe/Lisbon date '+%Y-%m-%d %H:%M:%S %Z')"
                  TEXT2="$(printf '⚙️ *[GitHub Actions LOOP]*\nEstado: *PUBLIC* • Fonte: %s\nMotivo: Transição confirmada para PÚBLICO\nPerfil: [@%s](https://x.com/%s)\n🕒 Cadência ~1/min (loop interno)\n\nUTC: %s\nLisboa: %s' \
                    "$SRC" "$USERNAME" "$USERNAME" "$NOW_UTC_TS" "$NOW_PT_TS")"
                  curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                    -d chat_id="${TELEGRAM_CHAT_ID}" -d parse_mode="Markdown" \
                    --data-urlencode "text=${TEXT2}" >/dev/null || true
                fi
              else
                echo "PUBLIC not confirmed on 2nd read — suppressing alert."
                CUR_STATE="${RES2[0]:-UNKNOWN}"
                SRC="${RES2[1]:-unknown}"
              fi
            fi

            echo "$CUR_STATE" > out/state.txt
            echo "::endgroup::"
            echo "tick ${ITER}"
            ITER=$((ITER+1))
            sleep "${SLEEP_SECONDS}"
          done

      - name: Upload artifacts (state persistence)
        uses: actions/upload-artifact@v4
        with:
          name: x-endpoint-${{ env.USERNAME }}
          path: |
            out/state.txt
            out/profile.html
            out/widgets.json
